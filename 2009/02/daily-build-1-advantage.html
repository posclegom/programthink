<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Python script by program.think@gmail.com" />
<meta name="provider" content="program-think.blogspot.com" />
<link type="text/css" rel="stylesheet" href="../../css/program-think.css" />
<title>软件工程进阶之每日构建[1]：好处和优点 - 编程随想的博客</title>
</head>
<body>
<div id="main" style="width:100%;">
<h1><a href="../../index.html" title="回到首页">软件工程进阶之每日构建[1]：好处和优点</a></h1>
<div class="post-info"><span class="date-header">2009-02-16</span><a href="../../tags/E7BC96E7A88B.html" class="tag">编程</a> <a href="../../tags/E7BC96E7A88B.E8BDAFE4BBB6E5B7A5E7A88B.html" class="tag">编程.软件工程</a> </div>
<hr/>
<div class="post">
&#12288;&#12288;上一个帖子《<a href="../../2009/02/daily-build-0-overview.html">软件工程进阶之每日构建[0]：概述</a>》提到说每日构建是一种很牛X的软件工程手段。本帖子就来说说它到底有多牛X。为了加深大伙儿的印象，俺先来说一些陈年往事。<a name='more'></a><!--program-think--><br /><br /><h2>★一个反面教材</h2><br />&#12288;&#12288;话说上世纪末，俺还在一家小公司干活，并参与开发了一个 C++ 项目。当时公司的流程是：<br />开发人员写好代码，自己编译好，丢给测试人员测试；<br />测试人员如果发现bug，口头通知开发人员改；<br />开发人员改好 bug，再丢给测试人员测试<br />......<br /><br /><h3>◇弊端1——开发的混乱</h3><br />&#12288;&#12288;有一天，开发组的小头目找来程序员甲。<br /><blockquote>>>小头目：你负责的 XX 功能完成了没有？<br />>>程序员甲：早做完啦！<br />>>小头目：那测试人员乙怎么说一直没看到 XX 功能？<br />>>程序员甲：不会吧！我去瞧瞧。</blockquote>若干分钟后，程序员甲回来。<br /><blockquote>>>程序员甲：不好意思，编译好的 EXE 我只发给了测试人员丙，忘记发给测试人员乙了。<br />>>小头目：!@#$%^&amp;*（此处省略15字）</blockquote><br /><h3>★弊端2——测试的混乱</h3><br />&#12288;&#12288;另一天刚上班。<br /><blockquote>>>测试人员甲：今天开发提交的 XX.EXE 怎么一运行就崩溃？<br />>>测试人员乙：有吗？我这儿好好的呀！<br />>>测试人员甲：真见鬼！我找开发问一下。</blockquote>&#12288;&#12288;经过若干分钟打听，知道 XX.EXE 是程序员丙负责，于是找来程序员丙。<br /><blockquote>>>测试人员甲：为啥你做的 XX.EXE 一运行就崩溃？<br />>>程序员丙：有这回事？！让我看看你的环境。</blockquote>&#12288;&#12288;程序员丙在测试人员甲的机器上研究了 N 刻钟后。<br /><blockquote>>>程序员丙：你是猪脑啊，你没有更新 XXX.DLL，害我浪费这么长时间！<br />>>测试人员甲：你才是猪脑！我怎么知道 XX.EXE 会用到 XXX.DLL？</blockquote>&#12288;&#12288;然后两人开始对骂......<br /><br /><h3>◇弊端3——集成的混乱</h3><br />&#12288;&#12288;项目交付日期临近了，开发人员都在忙着改 bug，测试人员都在忙着复测 bug，没有人手准备安装包。于是，安装包的制作一直拖到项目交付的前一天才开始搞。<br />&#12288;&#12288;制作安装包本身倒是很快，半天就搞定。但是......<br /><blockquote>>>小头目：做好的安装包应该没什么问题吧？<br />>>测试人员丙：呃，这个，这个......好像装出来的软件有问题，一运行直接崩溃了。<br />>>小头目：额滴神啊！还愣着干嘛，快去查原因！！！今天不搞定大家不许回家！！！</blockquote>&#12288;&#12288;然后开发和测试通力协作，经过艰苦卓绝的努力，到了午夜时分，终于发现：有个 DLL 竟然是 Debug 版本！<br />&#12288;&#12288;有同学可能会问：为啥平时测试的时候没发现这个问题捏？<br />&#12288;&#12288;因为平时团队里面都使用 Debug 版本，方便用 ASSERT 断言。到了作安装包那天，照道理应该统一编译 Release 版本，但是有个家伙遗漏了，所以混了一个 Debug 版本的 DLL 在里面。等安装完运行程序时，该 DLL 动态加载失败，所以程序就崩溃鸟。<br /><br /><br /><h2>★每日构建如何解决上述弊端？</h2><br />&#12288;&#12288;俺上面说的这些情形，到今天为止，还在很多公司内部上演。那为啥每日构建能搞定上面这些问题捏？且听俺细细道来：<br /><br /><h3>◇针对“开发的混乱”</h3><br />&#12288;&#12288;对于每日构建的流程，开发人员只要负责提交代码到代码库中，【不】需要挨个给测试人员提供编译后的二进制文件。<br />&#12288;&#12288;因此“弊端1”的问题（提交给测试的文件有遗漏）就迎刃而解了。<br /><br /><h3>◇针对“测试的混乱”</h3><br />&#12288;&#12288;在开发阶段，由于测试拿到的程序都是自动编译出来的，因此保证了所有测试人员拿到的是【统一的】运行程序，并且这个程序和代码库中最新的代码是相对应的。<br />&#12288;&#12288;在测试阶段，每一个开发人员修复了 Bug 之后，都必须把改过的代码提交到代码库；然后通过“自动编译”，修复了 Bug 的二进制软件包才会到测试人员手中。如果某个开发人员改了 Bug 但是没有提交代码，那么在测试人员看来，相当于他的 Bug 一直没有改，因此他的 Bug 就一直不会被关闭。<br />&#12288;&#12288;所以“弊端2”的情况也不会出现。<br /><br /><h3>◇针对“集成的混乱”</h3><br />&#12288;&#12288;对于每日构建来说，每天都会生成安装包（或者“安装光盘的ISO镜像”）。也就是说，从项目开始开发的那天起，每天都在进行集成（这就是传说中的【持续集成】）。因此，集成的问题，在一开始就会暴露出来，而不用等到项目后期。<br /><br /><br />&#12288;&#12288;其实每日构建的好处除了上述三点（这三点俺认为比较重要），还有其它很多，大伙儿可以自己再琢磨一下。<br />&#12288;&#12288;<a href="../../2009/02/daily-build-2-prepare.html">后面一个帖子</a>，俺把每日构建需要的准备工作介绍一下。<div class="blogger-post-footer">
</div>
<hr/>
<div class="copyright">
<h4>版权声明</h4>
本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者<a href="mailto:program.think@gmail.com">编程随想</a>和本文原始网址：<br>
<a href="https://program-think.blogspot.com/2009/02/daily-build-1-advantage.html">https://program-think.blogspot.com/2009/02/daily-build-1-advantage.html</a>
</div>
</div>
</body>
</html>
